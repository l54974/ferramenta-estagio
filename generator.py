import os
import ast
import itertools
import importlib.util
import sys
from ai_suggestions import extrair_valores_de_testes, valores_mais_frequentes

VALORES_POR_TIPO = {
    "int": ["0", "1", "-1"],
    "float": ["0.0", "-1.5", "3.14"],
    "str": ['""', '"abc"', '"xyz"'],
    "bool": ["True", "False"]
}

# Mistura com valores “aprendidos”
VALORES_APRENDIDOS = valores_mais_frequentes(extrair_valores_de_testes())

NUM_TESTES_POR_FUNCAO = 3

def inferir_tipo(arg_node):
    if arg_node.annotation:
        if isinstance(arg_node.annotation, ast.Name):
            return arg_node.annotation.id
        elif isinstance(arg_node.annotation, ast.Subscript):
            return arg_node.annotation.value.id
    return None

def gerar_valores_para_tipo(tipo):
    if tipo in VALORES_APRENDIDOS:
        return VALORES_APRENDIDOS[tipo]
    return VALORES_POR_TIPO.get(tipo, ["None"])

def gerar_combinacoes(valores_por_param):
    todas = list(itertools.product(*valores_por_param))
    return todas[:NUM_TESTES_POR_FUNCAO]

def importar_modulo(caminho_completo, nome_modulo):
    try:
        root_dir = os.path.dirname(os.path.abspath(caminho_completo))
        if root_dir not in sys.path:
            sys.path.insert(0, root_dir)

        spec = importlib.util.spec_from_file_location(nome_modulo, caminho_completo)
        if spec is None:
            print(f"Erro ao criar spec para {caminho_completo}")
            return None

        modulo = importlib.util.module_from_spec(spec)

        try:
            spec.loader.exec_module(modulo)
        except ModuleNotFoundError as e:
            print(f"Erro ao importar {nome_modulo}: {e}")
            return None
        except Exception as e:
            print(f"Erro inesperado ao importar {nome_modulo}: {e}")
            return None

        return modulo

    except Exception as e:
        print(f"Erro ao processar {nome_modulo}: {e}")
        return None

def gerar_testes(funcoes, nome_modulo, caminho_modulo=None, pasta_saida="tests"):
    os.makedirs(pasta_saida, exist_ok=True)
    nome_arquivo = os.path.join(pasta_saida, f"test_{nome_modulo}.py")

    if caminho_modulo:
        modulo_importado = importar_modulo(caminho_modulo, nome_modulo)
    else:
        modulo_importado = importar_modulo(os.path.join("exemplos", f"{nome_modulo}.py"), nome_modulo)

    if not modulo_importado:
        print(f"Erro: Módulo {nome_modulo} não foi importado com sucesso.")
        return

    with open(nome_arquivo, "w") as f:
        f.write("import unittest\n")
        f.write("import sys\n")
        f.write("import os\n")
        if caminho_modulo:
            f.write(f"sys.path.insert(0, os.path.abspath('{os.path.dirname(caminho_modulo)}'))\n")
        else:
            f.write("sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../exemplos')))\n")
        f.write(f"from {nome_modulo} import *\n\n")
        f.write("class TestAutoGenerated(unittest.TestCase):\n")

        for func in funcoes:
            nome_func = func.name
            args = func.args.args

            tipos = [inferir_tipo(arg) for arg in args]
            valores_por_param = [gerar_valores_para_tipo(t) for t in tipos]

            combinacoes = gerar_combinacoes(valores_por_param)

            for i, combinacao in enumerate(combinacoes):
                param_str = ", ".join(combinacao)

                try:
                    valores_exec = [eval(v) for v in combinacao]
                    func_ref = getattr(modulo_importado, nome_func)
                    resultado_real = func_ref(*valores_exec)
                    esperado_str = repr(resultado_real)
                except Exception:
                    esperado_str = "None"

                f.write(f"    def test_{nome_func}_{i}(self):\n")
                f.write(f"        resultado = {nome_func}({param_str})\n")
                f.write(f"        self.assertEqual(resultado, {esperado_str})\n\n")
